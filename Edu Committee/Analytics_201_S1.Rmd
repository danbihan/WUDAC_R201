---
title: 'Analytics 201: Session 1'
output:
  html_document:
    df_print: paged
---

Welcome to WUDAC Analytics 201, Fall 2020! 

In this session, we will learn how to read in a dataset, clean it up, and manipulate it using a package called _dplyr_.


# Reading in data

We will be working with a wine dataset from the [UCI Machine Learning Repository](https://archive.ics.uci.edu/ml/index.php). Let's see how to read it into your R workspace.

[Click here](https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-white.csv) to download the file containing the data.

```{r}
# First, move the the file to your desired folder location.
# Then, let's tell R where to find the file.

getwd() # this calls the current working directory

# If this is not where you want to save your work, change your path using the command below:
#setwd("C:/your/desired/path")
```
  
Once the file is in the right location, we can read in the dataset.
```{r}
# The file extension is .csv, so we use the classic read.csv() command
data <- read.csv('https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-white.csv', sep=';')

### Notice the "sep=';'" argument? That tells R to recognize ";" as the delimiter (typically, the delimiter is a comma, and we don't have to specify it.)
```

Now we have our data stored in a variable, so we are ready to clean it up.
  
  
### JOIN
In the real data world, it's often rare that every piece of information you want is stored in a single dataframe. Usually, different concepts are stored in different dataframes. There are many reasons for doing so:

* If we have lots of data, we might not have enough storage to store all information in one place
* We might not need all the data at once, so keeping them separate will allow for faster computations
* ...

Hence, when we have two (or more) datasets, each storing pieces of information we want, join is often used to combine them.

```{r data, echo = F}
#read in data
students <- read.csv('students.csv', header = T)
colnames(students)[1] <- gsub('^...','',colnames(students)[1])

majors <- read.csv('majors.csv', header = T)
colnames(majors)[1] <- gsub('^...','',colnames(majors)[1])
```

```{r print}
print(students)
print(majors)
```

Say we want to find out what major each student has. We can't just get the data from any single dataset, so we need to put the two datasets together. For a join statement, there are 3 pieces of key information:

1. Type of join (to be discussed)
2. Names of the data frames
3. The columns on which the join takes place

The syntax for join is: 
joined_data <- type_of_join(df1, df2, by = "name of the column")

```{r join}
joined_data <- inner_join(students, majors, by = "MajorID")
print(joined_data)
```

Combining with the select statement we discussed earlier, we can create a dataset with only the student name and their major

```{r major}
student_major <- select(joined_data, c("Name", "Major_Name"))
print(student_major)
```

#### Types of Join
There are 4 common types of joins, which are: 

* inner_join: Returns records that have matching values in both tables
* left_join: Returns all records from the left table, and the matched records from the right table
* right_join: Returns all records from the right table, and the matched records from the left table
* full_join: Returns all records when there is a match in either left or right table

![](https://d33wubrfki0l68.cloudfront.net/aeab386461820b029b7e7606ccff1286f623bae1/ef0d4/diagrams/join-venn.png){width=50%}


It's important to recognize which type of join should be used in a query. For example, if we have a table of __people__ and a table of __allergies__ with speicfic allergy types and the poeple who have that type of allergy, to know what kind of allergies each person has, it's probably a wise idea to do a LEFT JOIN from __people__ to __allergies__ (i.e. keeping all records in people) since many won't have an allergy and won't show up in the __allergies__ table.


### MERGE
Merge has basically the same functionality of join. It uses base R instead of dplyr (in other words you don't need to import any package for this). But join is designed to be a bit faster and work more efficiently that merge, so it's always recommended to use join over merge.

General merge syntax:
merged_date <- merge(df1, df2, by = "name of column to join on", type of join).

More specifically, we have:

* outer_join = merge(df1, df2, by = "colx", all = TRUE)
* left_join = merge(df1, df2, by = "colx", all.x = TRUE)    
* right_join = merge(df1, df2, by = "colx", all.y = TRUE)
  
  
# Tidying Data
```{r}
#Insert Data
```

```{r}
#Tidying Data
library(tidyverse)
```

```{r}
#Sample of dataset
arrests.sample = sample_n(arrests, size =10000)   #Specific number of rows, we'll use this dataset moving forward
arrests.samplefrac = sample_frac(arrests, 0.01)  #Specific fraction of rows
```


```{r}
#A good way to organize data is with dplyr
arrests.hour.race = arrests.sample %>% group_by(hour, sub_race) %>% count()
arrests.hour.race
```


```{r}
#What about the NA values? (Use filter function)
arrests.sample %>% filter(!is.na(sub_race)) %>% group_by(hour, sub_race) %>% count()
#Or use drop_na
arrests.sample = drop_na(arrests.sample, c(sub_race, sub_gender))
```


```{r}
#Other filter functionality
#Specific values (numeric)
arrests.afternoon = arrests.sample %>% filter(hour >= 12 & hour <20)
arrests.morning = arrests.sample %>% filter(hour >= 5 & hour <12)
#Filtering characters
arrests.violent.property = arrests.sample %>% filter(crime_code == c("violent", "property"))
arrests.violent.property %>% group_by(crime_code, sub_gender) %>% count()
```


```{r}
#Combining Columns (Ex.Combining race and gender columns)
arrests.sample = unite(arrests.sample, sub_race, sub_gender, col = "race_and_gender", sep = " ") 
arrests.sample %>% group_by(race_and_gender) %>% count()
```

```{r}
#Separating Columns
#Lets split this column back into the original two columns
separate(arrests.sample, race_and_gender, sep = " ", into = c("sub_race", "sub_gender"))
```

```{r}
#Renaming columns (You can use the rename function in dplyr)
#Lets rename off_id to officer_id
rename(arrests.sample, Officer_id = off_id)   #Set new name = old name
```

```{r}
#Creating new columns (mutate function)
arrests.sample= arrests.sample %>% mutate(afternoon = if_else(hour >= 12, 1, 0))
```

```{r}
#Formatting Dates
#The Dates are currently in the form of a character vector. How do you find the day of the months? Slicing?
library(lubridate) #Lubridate package for managing dates
ArrestDates = mdy(arrests.sample$date) #Convert the data into the date class
month(ArrestDates)  #Find the month that the arrests occurred in
```

```{r}
 write.csv(arrests.sample[1:12], "/Users/antoniojimenez/Downloads/Analytics 201\\arrestssample.csv")
```